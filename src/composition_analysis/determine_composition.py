import pandas as pd
import numpy as np
import h5py
import os

def determine_composition(decision_region, tasks, output_function=None, thresholds=[0.5]):
    """ Determine the composition of an individual decision region """
    if type(tasks) == list:
        raise NotImplementedError("Not yet implemented for list of tasks")
    if type(thresholds) != list: # support float/int thresholds
        thresholds = [thresholds] # TODO: single threshold for multiple tasks?
    DR = decision_region[:]
    if output_function is not None:
        DR = output_function(DR)
    if len(tasks) == 1:
        DR = DR.reshape(DR.size, 1)
    df = pd.DataFrame(DR,columns=tasks.keys())
    percent_compositions = {}
    for i, task  in enumerate(tasks):
        df[task] = np.where(DR[:, i] > thresholds[i], tasks[task][1], tasks[task][0])
        # get percent assigned to each task option
        gb = df.groupby(task).size()
        for opt in tasks[task].values():
            if opt not in gb: # this class is not in the decision region
                percent_compositions[f"{task}:{opt}"] = 0
            else:
                percent_compositions[f"{task}:{opt}"] = (gb[opt]/len(df))*100
    return percent_compositions

def get_compositions(filepath, tasks, output_function:str=None, thresholds:list=[0.5], aggregate:str=None):
    """ Gets the compositions of all decision regions in a decision region file"""
    file = h5py.File(filepath, 'r')
    percent_compositions = []
    att_cols = set()
    for group in file.keys():
        for region in file[group].keys():
            if region.endswith("__coordinates"):
                continue
            pc = determine_composition(file[group][region], tasks=tasks, output_function=output_function, thresholds=thresholds)
            pc['group'] = group
            pc['region'] = region
            for att in file[group].attrs:
                pc[att] = file[group].attrs[att]
                att_cols.add(att)
            percent_compositions.append(pc)
    df = pd.DataFrame.from_records(percent_compositions)
    numeric_cols = list(df.select_dtypes(include=np.number).columns)
    if not aggregate: 
        return df
    elif aggregate == 'group':
        return df.groupby(['group'] + list(att_cols))[numeric_cols].agg(['mean','std'])
    elif aggregate == 'all':
        return df[numeric_cols].agg(['mean','std'])
    elif aggregate == 'class':
        df_list = [df.groupby(task)[numeric_cols].agg(['mean','std']) for task in tasks]
        if len(df_list) == 1:
            return df_list[0]
        else:
            return df_list

def save_compositions(compositions:pd.DataFrame, save_loc:str, overwrite:bool=False, aggregate:str=None):
    """ Saves the compositions generated by get_compositions"""
    if aggregate is None:
        save_name = f"{save_loc}/decision_region_compositions.csv"
    else:
        save_name = f"{save_loc}/decision_region_compositions_{aggregate}.csv"
    if os.path.exists(save_name) and not overwrite:
        i = 1
        save_name = save_name.replace(".csv",f"_({i}).csv")
        while os.path.exists(save_name):
            save_name = save_name.replace(f"_({i}).csv",f"_({i+1}).csv")
            i += 1
    print(f"Saving decision region compositions to file: {save_name}")
    compositions.to_csv(save_name) 



        
    